package electory.client.audio.modplug;

import java.nio.ByteBuffer;
import java.nio.IntBuffer;

import com.sun.jna.Callback;
import com.sun.jna.Library;
import com.sun.jna.Native;
import com.sun.jna.NativeLibrary;
import com.sun.jna.NativeLong;
import com.sun.jna.Platform;
import com.sun.jna.Pointer;
import com.sun.jna.PointerType;
import com.sun.jna.ptr.IntByReference;
import com.sun.jna.ptr.PointerByReference;

/**
 * JNA Wrapper for library <b>ModPlug</b><br>
 * This file was autogenerated by
 * <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that
 * <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a
 * few opensource projects.</a>.<br>
 * For help, please visit
 * <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> ,
 * <a href="http://rococoa.dev.java.net/">Rococoa</a>, or
 * <a href="http://jna.dev.java.net/">JNA</a>.
 */
public interface ModPlugLibrary extends Library {
	static String getLibraryName() {
		if(Platform.isWindows()) {
			return "modplug.dll";
		}
		if(Platform.isLinux()) {
			return "libmodplug.so";
		}
		if(Platform.isMac()) {
			return "libmodplug.dylib";
		}
		throw new UnsupportedOperationException(); 
	}
	
	public static final String JNA_LIBRARY_NAME = getLibraryName();
	public static final NativeLibrary JNA_NATIVE_LIB = NativeLibrary.getInstance(ModPlugLibrary.JNA_LIBRARY_NAME);
	public static final ModPlugLibrary INSTANCE = (ModPlugLibrary) Native.load(	ModPlugLibrary.JNA_LIBRARY_NAME,
																				ModPlugLibrary.class);

	/**
	 * <i>native declaration : line 71</i><br>
	 * enum values
	 */
	public static interface _ModPlug_Flags {
		/**
		 * Enable oversampling (*highly* recommended)<br>
		 * <i>native declaration : line 73</i>
		 */
		public static final int MODPLUG_ENABLE_OVERSAMPLING = 1 << 0;
		/**
		 * Enable noise reduction<br>
		 * <i>native declaration : line 74</i>
		 */
		public static final int MODPLUG_ENABLE_NOISE_REDUCTION = 1 << 1;
		/**
		 * Enable reverb<br>
		 * <i>native declaration : line 75</i>
		 */
		public static final int MODPLUG_ENABLE_REVERB = 1 << 2;
		/**
		 * Enable megabass<br>
		 * <i>native declaration : line 76</i>
		 */
		public static final int MODPLUG_ENABLE_MEGABASS = 1 << 3;
		/**
		 * Enable surround sound.<br>
		 * <i>native declaration : line 77</i>
		 */
		public static final int MODPLUG_ENABLE_SURROUND = 1 << 4;
	};

	/**
	 * <i>native declaration : line 80</i><br>
	 * enum values
	 */
	public static interface _ModPlug_ResamplingMode {
		/**
		 * No interpolation (very fast, extremely bad sound quality)<br>
		 * <i>native declaration : line 82</i>
		 */
		public static final int MODPLUG_RESAMPLE_NEAREST = 0;
		/**
		 * Linear interpolation (fast, good quality)<br>
		 * <i>native declaration : line 83</i>
		 */
		public static final int MODPLUG_RESAMPLE_LINEAR = 1;
		/**
		 * Cubic spline interpolation (high quality)<br>
		 * <i>native declaration : line 84</i>
		 */
		public static final int MODPLUG_RESAMPLE_SPLINE = 2;
		/**
		 * 8-tap fir filter (extremely high quality)<br>
		 * <i>native declaration : line 85</i>
		 */
		public static final int MODPLUG_RESAMPLE_FIR = 3;
	};

	public interface ModPlugMixerProc extends Callback {
		void apply(IntByReference intPtr1, NativeLong long1, NativeLong long2);
	};

	/**
	 * Load a mod file. [data] should point to a block of memory containing the
	 * complete<br>
	 * file, and [size] should be the size of that block.<br>
	 * Return the loaded mod file on success, or NULL on failure.<br>
	 * Original signature :
	 * <code>ModPlugFile* ModPlug_Load(const void*, int)</code><br>
	 * <i>native declaration : line 47</i>
	 */
	ModPlugFile ModPlug_Load(Pointer data, int size);

	/**
	 * Unload a mod file.<br>
	 * Original signature : <code>void ModPlug_Unload(ModPlugFile*)</code><br>
	 * <i>native declaration : line 49</i><br>
	 */
	void ModPlug_Unload(ModPlugFile file);

	/**
	 * Read sample data into the buffer. Returns the number of bytes read. If the
	 * end<br>
	 * of the mod has been reached, zero is returned.<br>
	 * Original signature :
	 * <code>int ModPlug_Read(ModPlugFile*, void*, int)</code><br>
	 * <i>native declaration : line 53</i><br>
	 */
	int ModPlug_Read(ModPlugFile file, Pointer buffer, int size);

	/**
	 * Get the name of the mod. The returned buffer is stored within the
	 * ModPlugFile<br>
	 * structure and will remain valid until you unload the file.<br>
	 * Original signature : <code>char* ModPlug_GetName(ModPlugFile*)</code><br>
	 * <i>native declaration : line 57</i><br>
	 */
	String ModPlug_GetName(ModPlugFile file);

	/**
	 * Get the length of the mod, in milliseconds. Note that this result is not
	 * always<br>
	 * accurate, especially in the case of mods with loops.<br>
	 * Original signature : <code>int ModPlug_GetLength(ModPlugFile*)</code><br>
	 * <i>native declaration : line 61</i><br>
	 */
	int ModPlug_GetLength(ModPlugFile file);

	/**
	 * Seek to a particular position in the song. Note that seeking and MODs don't
	 * mix very<br>
	 * well. Some mods will be missing instruments for a short time after a seek, as
	 * ModPlug<br>
	 * does not scan the sequence backwards to find out which instruments were
	 * supposed to be<br>
	 * playing at that time. (Doing so would be difficult and not very reliable.)
	 * Also,<br>
	 * note that seeking is not very exact in some mods -- especially those for
	 * which<br>
	 * ModPlug_GetLength() does not report the full length.<br>
	 * Original signature : <code>void ModPlug_Seek(ModPlugFile*, int)</code><br>
	 * <i>native declaration : line 69</i><br>
	 */
	void ModPlug_Seek(ModPlugFile file, int millisecond);

	/**
	 * Get and set the mod decoder settings. All options, except for channels,
	 * bits-per-sample,<br>
	 * sampling rate, and loop count, will take effect immediately. Those options
	 * which don't<br>
	 * take effect immediately will take effect the next time you load a mod.<br>
	 * Original signature :
	 * <code>void ModPlug_GetSettings(ModPlug_Settings*)</code><br>
	 * <i>native declaration : line 115</i>
	 */
	void ModPlug_GetSettings(ModPlug_Settings settings);

	/**
	 * Original signature :
	 * <code>void ModPlug_SetSettings(const ModPlug_Settings*)</code><br>
	 * <i>native declaration : line 116</i>
	 */
	void ModPlug_SetSettings(ModPlug_Settings settings);

	/**
	 * NOTE: Master Volume (1-512)<br>
	 * Original signature :
	 * <code>int ModPlug_GetMasterVolume(ModPlugFile*)</code><br>
	 * <i>native declaration : line 120</i><br>
	 */
	int ModPlug_GetMasterVolume(ModPlugFile file);

	/**
	 * Original signature :
	 * <code>void ModPlug_SetMasterVolume(ModPlugFile*, unsigned int)</code><br>
	 * <i>native declaration : line 121</i><br>
	 */
	void ModPlug_SetMasterVolume(ModPlugFile file, int cvol);

	/**
	 * Original signature :
	 * <code>int ModPlug_GetCurrentSpeed(ModPlugFile*)</code><br>
	 * <i>native declaration : line 123</i><br>
	 */
	int ModPlug_GetCurrentSpeed(ModPlugFile file);

	/**
	 * Original signature :
	 * <code>int ModPlug_GetCurrentTempo(ModPlugFile*)</code><br>
	 * <i>native declaration : line 124</i><br>
	 */
	int ModPlug_GetCurrentTempo(ModPlugFile file);

	/**
	 * Original signature :
	 * <code>int ModPlug_GetCurrentOrder(ModPlugFile*)</code><br>
	 * <i>native declaration : line 125</i><br>
	 */
	int ModPlug_GetCurrentOrder(ModPlugFile file);

	/**
	 * Original signature :
	 * <code>int ModPlug_GetCurrentPattern(ModPlugFile*)</code><br>
	 * <i>native declaration : line 126</i><br>
	 */
	int ModPlug_GetCurrentPattern(ModPlugFile file);

	/**
	 * Original signature : <code>int ModPlug_GetCurrentRow(ModPlugFile*)</code><br>
	 * <i>native declaration : line 127</i><br>
	 */
	int ModPlug_GetCurrentRow(ModPlugFile file);

	/**
	 * Original signature :
	 * <code>int ModPlug_GetPlayingChannels(ModPlugFile*)</code><br>
	 * <i>native declaration : line 128</i><br>
	 */
	int ModPlug_GetPlayingChannels(ModPlugFile file);

	/**
	 * Original signature :
	 * <code>void ModPlug_SeekOrder(ModPlugFile*, int)</code><br>
	 * <i>native declaration : line 130</i><br>
	 */
	void ModPlug_SeekOrder(ModPlugFile file, int order);

	/**
	 * Original signature : <code>int ModPlug_GetModuleType(ModPlugFile*)</code><br>
	 * <i>native declaration : line 131</i><br>
	 */
	int ModPlug_GetModuleType(ModPlugFile file);

	/**
	 * Original signature : <code>char* ModPlug_GetMessage(ModPlugFile*)</code><br>
	 * <i>native declaration : line 132</i><br>
	 */
	String ModPlug_GetMessage(ModPlugFile file);

	/**
	 * Original signature :
	 * <code>int ModPlug_NumInstruments(ModPlugFile*)</code><br>
	 * <i>native declaration : line 152</i><br>
	 */
	int ModPlug_NumInstruments(ModPlugFile file);

	/**
	 * Original signature : <code>int ModPlug_NumSamples(ModPlugFile*)</code><br>
	 * <i>native declaration : line 153</i><br>
	 */
	int ModPlug_NumSamples(ModPlugFile file);

	/**
	 * Original signature : <code>int ModPlug_NumPatterns(ModPlugFile*)</code><br>
	 * <i>native declaration : line 154</i><br>
	 */
	int ModPlug_NumPatterns(ModPlugFile file);

	/**
	 * Original signature : <code>int ModPlug_NumChannels(ModPlugFile*)</code><br>
	 * <i>native declaration : line 155</i><br>
	 */
	int ModPlug_NumChannels(ModPlugFile file);
	
	/**
	 * Original signature :
	 * <code>int ModPlug_SampleName(ModPlugFile*, unsigned int, char*)</code><br>
	 * <i>native declaration : line 156</i>
	 */
	int ModPlug_SampleName(ModPlugFile file, int qual, ByteBuffer buff);
	
	/**
	 * Original signature :
	 * <code>int ModPlug_InstrumentName(ModPlugFile*, unsigned int, char*)</code><br>
	 * <i>native declaration : line 157</i>
	 */
	int ModPlug_InstrumentName(ModPlugFile file, int qual, ByteBuffer buff);
	
	/**
	 * Retrieve pattern note-data<br>
	 * Original signature :
	 * <code>ModPlugNote* ModPlug_GetPattern(ModPlugFile*, int, unsigned int*)</code><br>
	 * <i>native declaration : line 162</i>
	 */
	ModPlugNote ModPlug_GetPattern(ModPlugFile file, int pattern, IntBuffer numrows);

	/**
	 * =================<br>
	 * Mixer callback<br>
	 * =================<br>
	 * Use this callback if you want to 'modify' the mixed data of LibModPlug.<br>
	 * <br>
	 * void proc(int* buffer,unsigned long channels,unsigned long nsamples) ;<br>
	 * 'buffer': A buffer of mixed samples<br>
	 * 'channels': N. of channels in the buffer<br>
	 * 'nsamples': N. of samples in the buffeer (without taking care of
	 * n.channels)<br>
	 * (Samples are signed 32-bit integers)<br>
	 * Original signature :
	 * <code>void ModPlug_InitMixerCallback(ModPlugFile*, ModPlugMixerProc)</code><br>
	 * <i>native declaration : line 179</i>
	 */
	void ModPlug_InitMixerCallback(ModPlugFile file, ModPlugLibrary.ModPlugMixerProc proc);

	/**
	 * Original signature :
	 * <code>void ModPlug_UnloadMixerCallback(ModPlugFile*)</code><br>
	 * <i>native declaration : line 180</i>
	 */
	void ModPlug_UnloadMixerCallback(ModPlugFile file);

	public static class ModPlugFile extends PointerType {
		public ModPlugFile(Pointer address) {
			super(address);
		}

		public ModPlugFile() {
			super();
		}
	};
}
